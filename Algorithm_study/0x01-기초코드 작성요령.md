# 1. 시간, 공간복잡도

연산 횟수 5n+3 이면 n에 비례

### 예1
```
N명의 사람들이 일렬로 서있을 때 특정 이름을 찾으려 한다. 
이름을 묻고 대답을 듣는데까지 1초가 걸린다면 얼마만큼의 시간이 필요할까?
```

최대 N초, 최소 1초, 평균적으로 N/2초 -> 걸리는 시간은 N에 비례


```
N명의 사람들이 일렬로 서있을 때 특정 이름을 찾으려 한다. 이름순으로 사람들이 서있을 때,
이름을 묻고 대답을 듣는데까지 1초가 걸린다면 얼마만큼의 시간이 필요할까?
```

최대 log N초, 최소 1초, 평균적으로 log N초 -> 걸리는 시간은 log N에 비례

----------------

## 시간 복잡도(Time Complexity)
* 입력의 크기와 문제를 해결하는 데 걸리는 시간의 상관관계
* 빅오 표기법(Big-O Notation)
주어진 식을 값이 가장 큰 대표항만 남겨서 나타내는 방법
```
O(N): 5N + 3, 2N + 10lgN, 10N
O(N^2): N^2 + 2N + 4, 6N^2 + 20N + 10lgN
O(NlgN): NlgN + 30N + 10, 5NlgN + 6
O(1): 5, 16, 36

O(1) < O(lgN) < O(N) < O(NlgN) < O(N^2) < O(2^N) < O(N!)
```

### 예2
```
N 이하의 자연수 중에서 3의 배수이거나 5의 배수인 수를 모두 합한 값을 반환하는 함수 fun1(int N)을 작성하라. N은 5만 이하의 자연수이다.
```
시간복잡도가 O(N)이 나오는 이유 생각해보기


```
주어진 길이 N의 int 배열 arr에서 합이 100인 서로 다른 위치의 두 원소가 존재하면 1을, 존재하지 않으면 0을 반환하는 함수 func2(int arr[], int N)을 작성하라. arr의 각 수는 0 이상 100 이하이고, N은 1000 이하이다.
```
시간복잡도가 O(N^2)이 나오는 이유 생각해보기 (O(N)이 나올 수 있지만 나중에 설명)


### 예3
```
N이 제곱수이면 1을 반환하고 제곱수가 아니면 0을 반환하는 
함수 func3(int N)을 작성하라. N은 10억 이하의 자연수이다.
```
시간복잡도가 O(sqrt(N))이 나오는 이유 생각해보기
(루트 가능)

### 예4
```
N이하의 수 중에서 가장 큰 2의 거듭제곱수를 반환하는 함수 
func(int N)을 작성하라. N은 10억 이하의 자연수이다.
```
시간복잡도가 O(lgN)이 나오는 이유 생각해보기

----------------

## 공간 복잡도(Space Complexity)
* 입력의 크기와 문제를 해결하는데 필요한 공간의 상관관계

# 2. 정수 자료형
* unsigned char 자료형 범위 = 0 ~ 255 (00000000~11111111)
* signed char 자료형 범위 = -128 ~ 127 (10000000~01111111)
* short (2byte) 최대 = 2^15-1
* int (4byte) 최대 = 2^31-1
* long long (8byte) 최대 = 2^63-1



## Integer Overflow
```
// 128번에 걸쳐 hi를 출력하는 함수
void func1(){
    for(char s = 0; s < 128; s++){
        cout << "hi";
    }
}
```
s가 127에서 1이 더해지면 -128이기 때문에 무한루프에 빠짐 (Integer overflow)
-> char을 int로 바꿔야 함

```
// 10의 10 거듭제곱을 1000000007로 나눈 나머지를 반환하는 함수
int func3(){
    int a = 10;
    int mod = 100000007;
    for(int i = 0; i < 10; i++)
        a = 10 * a % mod;
    return a;
}
```
a^9에서 10이 한 번 더 곱해지는 순간 integer범위를 넘어서서 Integer Overflow 발생함
-> int를 long long으로 바꿔야 함
-> (또는) for문 안에 10대신 10ll혹은 (long long)10으로 강제 형 변환을 해줘야 함


# 3. 실수 자료형
* float (4byte): 유효숫자 6자리
* double (8 byte): 유효숫자 15자리

## 실수의 성질
1. 실수의 저장/연산과정에서 반드시 오차가 발생할 수 밖에 없다. (float대신 double로 사용하기)
2. double에 long long 범위의 정수를 함부로 담으면 안된다. 
(int는 최대 21억이어서 double에 담아도 오차가 생기지 않음)
3. 실수를 비교할 때는 등호를 사용하면 안된다. (0.1+0.1+0.1 != 0.3)